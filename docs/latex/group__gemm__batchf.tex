\hypertarget{group__gemm__batchf}{}\section{gemm\+\_\+batchf\+: Batch of same size general matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}}
\label{group__gemm__batchf}\index{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}}


$ C[i] = \alpha[i] \;op(A[i]) \;op(B[i]) + \beta[i] C[i] $  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__gemm__batchf_ga7638ee53c76c8e1b40dffa9574f5cbad}{blas\+\_\+cgemm\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, bblas\+\_\+complex32\+\_\+t alpha, bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$A, int lda, bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$B, int ldb, bblas\+\_\+complex32\+\_\+t beta, bblas\+\_\+complex32\+\_\+t $\ast$$\ast$C, int ldc, int $\ast$info)
\item 
void \hyperlink{group__gemm__batchf_gaa3c403cc8465c276b39d139275e5c0bd}{blas\+\_\+dgemm\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, double alpha, double const $\ast$const $\ast$A, int lda, double const $\ast$const $\ast$B, int ldb, double beta, double $\ast$$\ast$C, int ldc, int $\ast$info)
\item 
void \hyperlink{group__gemm__batchf_ga5b47cbf645948cf526faafecdd56ff35}{blas\+\_\+sgemm\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, float alpha, float const $\ast$const $\ast$A, int lda, float const $\ast$const $\ast$B, int ldb, float beta, float $\ast$$\ast$C, int ldc, int $\ast$info)
\item 
void \hyperlink{group__gemm__batchf_ga2b91753e96ae9bd05c75ebedd35cfce8}{blas\+\_\+zgemm\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, bblas\+\_\+complex64\+\_\+t alpha, bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$A, int lda, bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$B, int ldb, bblas\+\_\+complex64\+\_\+t beta, bblas\+\_\+complex64\+\_\+t $\ast$$\ast$C, int ldc, int $\ast$info)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
$ C[i] = \alpha[i] \;op(A[i]) \;op(B[i]) + \beta[i] C[i] $ 



\subsection{Function Documentation}
\index{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}!blas\+\_\+cgemm\+\_\+batchf@{blas\+\_\+cgemm\+\_\+batchf}}
\index{blas\+\_\+cgemm\+\_\+batchf@{blas\+\_\+cgemm\+\_\+batchf}!gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}}
\subsubsection[{\texorpdfstring{blas\+\_\+cgemm\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, bblas\+\_\+complex32\+\_\+t alpha, bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$\+A, int lda, bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$\+B, int ldb, bblas\+\_\+complex32\+\_\+t beta, bblas\+\_\+complex32\+\_\+t $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_cgemm_batchf(int group_size, bblas_enum_t layout, bblas_enum_t transa, bblas_enum_t transb, int m, int n, int k, bblas_complex32_t alpha, bblas_complex32_t const *const *A, int lda, bblas_complex32_t const *const *B, int ldb, bblas_complex32_t beta, bblas_complex32_t **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+cgemm\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{transa, }
\item[{bblas\+\_\+enum\+\_\+t}]{transb, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{bblas\+\_\+complex32\+\_\+t}]{alpha, }
\item[{bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$}]{B, }
\item[{int}]{ldb, }
\item[{bblas\+\_\+complex32\+\_\+t}]{beta, }
\item[{bblas\+\_\+complex32\+\_\+t $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__gemm__batchf_ga7638ee53c76c8e1b40dffa9574f5cbad}{}\label{group__gemm__batchf_ga7638ee53c76c8e1b40dffa9574f5cbad}
cgemm\+\_\+batchf is a batch version of cgemm. It performs matrix-\/matrix multiplication of matrices, where all the matrices of the batch have a fixed size.

\[ C[i] = \alpha [op( A[i] )\times op( B[i] )] + \beta C[i], \]

where op( X ) is one of\+: \[ op( X ) = X, \] \[ op( X ) = X^T, \] \[ op( X ) = X^H, \]

alpha and beta are scalars, and A\mbox{[}i\mbox{]}, B\mbox{[}i\mbox{]} and C\mbox{[}i\mbox{]} are matrices, with op( A\mbox{[}i\mbox{]} ) an m-\/by-\/k matrix, op( B\mbox{[}i\mbox{]} ) a k-\/by-\/n matrix and C\mbox{[}i\mbox{]} an m-\/by-\/n matrix. \begin{DoxyVerb}                                                                        i
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transa} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: A\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: A\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: A\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transb} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: B\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: B\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: B\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em m} & The number of rows of the matrix op( A\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrix op( B\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of columns of the matrix op( A\mbox{[}i\mbox{]} ) and the number of rows of the matrix op( B\mbox{[}i\mbox{]} ). k $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/ka, where ka is k when transa = Bblas\+No\+Trans, and is m otherwise. When using transa = Bblas\+No\+Trans the leading m-\/by-\/k part of A\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading k-\/by-\/m part of A\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A\mbox{[}i\mbox{]}. When transa = Bblas\+No\+Trans, lda $>$= max(1,m), otherwise, lda $>$= max(1,k).\\
\hline
\mbox{\tt in}  & {\em B} & B is an array of pointers to matrices B\mbox{[}0\mbox{]}, B\mbox{[}1\mbox{]},..,B\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element B\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/kb, where kb is n when transb = Bblas\+No\+Trans, and is k otherwise. When using transb = Bblas\+No\+Trans the leading k-\/by-\/n part of B\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading n-\/by-\/k part of B\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em ldb} & The leading dimension of the array B\mbox{[}i\mbox{]}. When transb = Bblas\+No\+Trans, ldb $>$= max(1,k), otherwise, ldb $>$= max(1,n).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]},...,C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element of C\mbox{[}i\mbox{]} is a pointer to a matrix of dimension ldc-\/by-\/n. On exit, each array C\mbox{[}i\mbox{]} is overwritten by the m-\/by-\/n matrix ( alpha$\ast$op(A\mbox{[}i\mbox{]} )$\ast$op( B\mbox{[}i\mbox{]} ) + beta$\ast$C\mbox{[}i\mbox{]} ).\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the array C\mbox{[}i\mbox{]}. ldc $>$= max(1,m).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be at least \{i=0\}$^\wedge$\{group\+\_\+count-\/1\}group\+\_\+size\mbox{[}i\mbox{]}.
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be at least group\+\_\+count.
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be at least 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be at least 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
cgemm\+\_\+batchf 

cgemm\+\_\+batchf 

dgemm\+\_\+batchf 

sgemm\+\_\+batchf 
\end{DoxySeeAlso}
\index{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}!blas\+\_\+dgemm\+\_\+batchf@{blas\+\_\+dgemm\+\_\+batchf}}
\index{blas\+\_\+dgemm\+\_\+batchf@{blas\+\_\+dgemm\+\_\+batchf}!gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}}
\subsubsection[{\texorpdfstring{blas\+\_\+dgemm\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, double alpha, double const $\ast$const $\ast$\+A, int lda, double const $\ast$const $\ast$\+B, int ldb, double beta, double $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_dgemm_batchf(int group_size, bblas_enum_t layout, bblas_enum_t transa, bblas_enum_t transb, int m, int n, int k, double alpha, double const *const *A, int lda, double const *const *B, int ldb, double beta, double **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+dgemm\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{transa, }
\item[{bblas\+\_\+enum\+\_\+t}]{transb, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{double}]{alpha, }
\item[{double const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{double const $\ast$const $\ast$}]{B, }
\item[{int}]{ldb, }
\item[{double}]{beta, }
\item[{double $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__gemm__batchf_gaa3c403cc8465c276b39d139275e5c0bd}{}\label{group__gemm__batchf_gaa3c403cc8465c276b39d139275e5c0bd}
dgemm\+\_\+batchf is a batch version of dgemm. It performs matrix-\/matrix multiplication of matrices, where all the matrices of the batch have a fixed size.

\[ C[i] = \alpha [op( A[i] )\times op( B[i] )] + \beta C[i], \]

where op( X ) is one of\+: \[ op( X ) = X, \] \[ op( X ) = X^T, \] \[ op( X ) = X^T, \]

alpha and beta are scalars, and A\mbox{[}i\mbox{]}, B\mbox{[}i\mbox{]} and C\mbox{[}i\mbox{]} are matrices, with op( A\mbox{[}i\mbox{]} ) an m-\/by-\/k matrix, op( B\mbox{[}i\mbox{]} ) a k-\/by-\/n matrix and C\mbox{[}i\mbox{]} an m-\/by-\/n matrix. \begin{DoxyVerb}                                                                        i
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transa} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: A\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: A\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: A\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transb} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: B\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: B\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: B\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em m} & The number of rows of the matrix op( A\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrix op( B\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of columns of the matrix op( A\mbox{[}i\mbox{]} ) and the number of rows of the matrix op( B\mbox{[}i\mbox{]} ). k $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/ka, where ka is k when transa = Bblas\+No\+Trans, and is m otherwise. When using transa = Bblas\+No\+Trans the leading m-\/by-\/k part of A\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading k-\/by-\/m part of A\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A\mbox{[}i\mbox{]}. When transa = Bblas\+No\+Trans, lda $>$= max(1,m), otherwise, lda $>$= max(1,k).\\
\hline
\mbox{\tt in}  & {\em B} & B is an array of pointers to matrices B\mbox{[}0\mbox{]}, B\mbox{[}1\mbox{]},..,B\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element B\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/kb, where kb is n when transb = Bblas\+No\+Trans, and is k otherwise. When using transb = Bblas\+No\+Trans the leading k-\/by-\/n part of B\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading n-\/by-\/k part of B\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em ldb} & The leading dimension of the array B\mbox{[}i\mbox{]}. When transb = Bblas\+No\+Trans, ldb $>$= max(1,k), otherwise, ldb $>$= max(1,n).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]},...,C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element of C\mbox{[}i\mbox{]} is a pointer to a matrix of dimension ldc-\/by-\/n. On exit, each array C\mbox{[}i\mbox{]} is overwritten by the m-\/by-\/n matrix ( alpha$\ast$op(A\mbox{[}i\mbox{]} )$\ast$op( B\mbox{[}i\mbox{]} ) + beta$\ast$C\mbox{[}i\mbox{]} ).\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the array C\mbox{[}i\mbox{]}. ldc $>$= max(1,m).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be at least \{i=0\}$^\wedge$\{group\+\_\+count-\/1\}group\+\_\+size\mbox{[}i\mbox{]}.
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be at least group\+\_\+count.
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be at least 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be at least 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
dgemm\+\_\+batchf 

cgemm\+\_\+batchf 

dgemm\+\_\+batchf 

sgemm\+\_\+batchf 
\end{DoxySeeAlso}
\index{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}!blas\+\_\+sgemm\+\_\+batchf@{blas\+\_\+sgemm\+\_\+batchf}}
\index{blas\+\_\+sgemm\+\_\+batchf@{blas\+\_\+sgemm\+\_\+batchf}!gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}}
\subsubsection[{\texorpdfstring{blas\+\_\+sgemm\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, float alpha, float const $\ast$const $\ast$\+A, int lda, float const $\ast$const $\ast$\+B, int ldb, float beta, float $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_sgemm_batchf(int group_size, bblas_enum_t layout, bblas_enum_t transa, bblas_enum_t transb, int m, int n, int k, float alpha, float const *const *A, int lda, float const *const *B, int ldb, float beta, float **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+sgemm\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{transa, }
\item[{bblas\+\_\+enum\+\_\+t}]{transb, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{float}]{alpha, }
\item[{float const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{float const $\ast$const $\ast$}]{B, }
\item[{int}]{ldb, }
\item[{float}]{beta, }
\item[{float $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__gemm__batchf_ga5b47cbf645948cf526faafecdd56ff35}{}\label{group__gemm__batchf_ga5b47cbf645948cf526faafecdd56ff35}
sgemm\+\_\+batchf is a batch version of sgemm. It performs matrix-\/matrix multiplication of matrices, where all the matrices of the batch have a fixed size.

\[ C[i] = \alpha [op( A[i] )\times op( B[i] )] + \beta C[i], \]

where op( X ) is one of\+: \[ op( X ) = X, \] \[ op( X ) = X^T, \] \[ op( X ) = X^T, \]

alpha and beta are scalars, and A\mbox{[}i\mbox{]}, B\mbox{[}i\mbox{]} and C\mbox{[}i\mbox{]} are matrices, with op( A\mbox{[}i\mbox{]} ) an m-\/by-\/k matrix, op( B\mbox{[}i\mbox{]} ) a k-\/by-\/n matrix and C\mbox{[}i\mbox{]} an m-\/by-\/n matrix. \begin{DoxyVerb}                                                                        i
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transa} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: A\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: A\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: A\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transb} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: B\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: B\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: B\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em m} & The number of rows of the matrix op( A\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrix op( B\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of columns of the matrix op( A\mbox{[}i\mbox{]} ) and the number of rows of the matrix op( B\mbox{[}i\mbox{]} ). k $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/ka, where ka is k when transa = Bblas\+No\+Trans, and is m otherwise. When using transa = Bblas\+No\+Trans the leading m-\/by-\/k part of A\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading k-\/by-\/m part of A\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A\mbox{[}i\mbox{]}. When transa = Bblas\+No\+Trans, lda $>$= max(1,m), otherwise, lda $>$= max(1,k).\\
\hline
\mbox{\tt in}  & {\em B} & B is an array of pointers to matrices B\mbox{[}0\mbox{]}, B\mbox{[}1\mbox{]},..,B\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element B\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/kb, where kb is n when transb = Bblas\+No\+Trans, and is k otherwise. When using transb = Bblas\+No\+Trans the leading k-\/by-\/n part of B\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading n-\/by-\/k part of B\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em ldb} & The leading dimension of the array B\mbox{[}i\mbox{]}. When transb = Bblas\+No\+Trans, ldb $>$= max(1,k), otherwise, ldb $>$= max(1,n).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]},...,C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element of C\mbox{[}i\mbox{]} is a pointer to a matrix of dimension ldc-\/by-\/n. On exit, each array C\mbox{[}i\mbox{]} is overwritten by the m-\/by-\/n matrix ( alpha$\ast$op(A\mbox{[}i\mbox{]} )$\ast$op( B\mbox{[}i\mbox{]} ) + beta$\ast$C\mbox{[}i\mbox{]} ).\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the array C\mbox{[}i\mbox{]}. ldc $>$= max(1,m).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be at least \{i=0\}$^\wedge$\{group\+\_\+count-\/1\}group\+\_\+size\mbox{[}i\mbox{]}.
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be at least group\+\_\+count.
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be at least 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be at least 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
sgemm\+\_\+batchf 

cgemm\+\_\+batchf 

dgemm\+\_\+batchf 

sgemm\+\_\+batchf 
\end{DoxySeeAlso}
\index{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}!blas\+\_\+zgemm\+\_\+batchf@{blas\+\_\+zgemm\+\_\+batchf}}
\index{blas\+\_\+zgemm\+\_\+batchf@{blas\+\_\+zgemm\+\_\+batchf}!gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C\mbox{[}i\mbox{]} = A\mbox{[}i\mbox{]}\+B\mbox{[}i\mbox{]} + C\mbox{[}i\mbox{]}@{gemm\+\_\+batchf\+:  Batch of same size general  matrix multiply\+: C[i] = A[i]B[i] + C[i]}}
\subsubsection[{\texorpdfstring{blas\+\_\+zgemm\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t transa, bblas\+\_\+enum\+\_\+t transb, int m, int n, int k, bblas\+\_\+complex64\+\_\+t alpha, bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$\+A, int lda, bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$\+B, int ldb, bblas\+\_\+complex64\+\_\+t beta, bblas\+\_\+complex64\+\_\+t $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_zgemm_batchf(int group_size, bblas_enum_t layout, bblas_enum_t transa, bblas_enum_t transb, int m, int n, int k, bblas_complex64_t alpha, bblas_complex64_t const *const *A, int lda, bblas_complex64_t const *const *B, int ldb, bblas_complex64_t beta, bblas_complex64_t **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+zgemm\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{transa, }
\item[{bblas\+\_\+enum\+\_\+t}]{transb, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{bblas\+\_\+complex64\+\_\+t}]{alpha, }
\item[{bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$}]{B, }
\item[{int}]{ldb, }
\item[{bblas\+\_\+complex64\+\_\+t}]{beta, }
\item[{bblas\+\_\+complex64\+\_\+t $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__gemm__batchf_ga2b91753e96ae9bd05c75ebedd35cfce8}{}\label{group__gemm__batchf_ga2b91753e96ae9bd05c75ebedd35cfce8}
zgemm\+\_\+batchf is a batch version of zgemm. It performs matrix-\/matrix multiplication of matrices, where all the matrices of the batch have a fixed size.

\[ C[i] = \alpha [op( A[i] )\times op( B[i] )] + \beta C[i], \]

where op( X ) is one of\+: \[ op( X ) = X, \] \[ op( X ) = X^T, \] \[ op( X ) = X^H, \]

alpha and beta are scalars, and A\mbox{[}i\mbox{]}, B\mbox{[}i\mbox{]} and C\mbox{[}i\mbox{]} are matrices, with op( A\mbox{[}i\mbox{]} ) an m-\/by-\/k matrix, op( B\mbox{[}i\mbox{]} ) a k-\/by-\/n matrix and C\mbox{[}i\mbox{]} an m-\/by-\/n matrix. \begin{DoxyVerb}                                                                        i
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transa} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: A\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: A\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: A\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em transb} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: B\mbox{[}i\mbox{]} is not transposed,
\item Bblas\+Trans\+: B\mbox{[}i\mbox{]} is transposed,
\item Bblas\+Conj\+Trans\+: B\mbox{[}i\mbox{]} is conjugate transposed.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em m} & The number of rows of the matrix op( A\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrix op( B\mbox{[}i\mbox{]} ) and of the matrix C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of columns of the matrix op( A\mbox{[}i\mbox{]} ) and the number of rows of the matrix op( B\mbox{[}i\mbox{]} ). k $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/ka, where ka is k when transa = Bblas\+No\+Trans, and is m otherwise. When using transa = Bblas\+No\+Trans the leading m-\/by-\/k part of A\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading k-\/by-\/m part of A\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A\mbox{[}i\mbox{]}. When transa = Bblas\+No\+Trans, lda $>$= max(1,m), otherwise, lda $>$= max(1,k).\\
\hline
\mbox{\tt in}  & {\em B} & B is an array of pointers to matrices B\mbox{[}0\mbox{]}, B\mbox{[}1\mbox{]},..,B\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element B\mbox{[}i\mbox{]} is a pointer to a matrix of dimension lda-\/by-\/kb, where kb is n when transb = Bblas\+No\+Trans, and is k otherwise. When using transb = Bblas\+No\+Trans the leading k-\/by-\/n part of B\mbox{[}i\mbox{]} must contain the matrix elements, otherwise the leading n-\/by-\/k part of B\mbox{[}i\mbox{]} must contain the matrix elements.\\
\hline
\mbox{\tt in}  & {\em ldb} & The leading dimension of the array B\mbox{[}i\mbox{]}. When transb = Bblas\+No\+Trans, ldb $>$= max(1,k), otherwise, ldb $>$= max(1,n).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]},...,C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element of C\mbox{[}i\mbox{]} is a pointer to a matrix of dimension ldc-\/by-\/n. On exit, each array C\mbox{[}i\mbox{]} is overwritten by the m-\/by-\/n matrix ( alpha$\ast$op(A\mbox{[}i\mbox{]} )$\ast$op( B\mbox{[}i\mbox{]} ) + beta$\ast$C\mbox{[}i\mbox{]} ).\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the array C\mbox{[}i\mbox{]}. ldc $>$= max(1,m).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be at least \{i=0\}$^\wedge$\{group\+\_\+count-\/1\}group\+\_\+size\mbox{[}i\mbox{]}.
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be at least group\+\_\+count.
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be at least 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be at least 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
zgemm\+\_\+batchf 

cgemm\+\_\+batchf 

dgemm\+\_\+batchf 

sgemm\+\_\+batchf 
\end{DoxySeeAlso}

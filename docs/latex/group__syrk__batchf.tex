\hypertarget{group__syrk__batchf}{}\section{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}
\label{group__syrk__batchf}\index{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}}


$ C[i] = \alpha[i] A[i] A[i]^T + \beta[i] C[i] $ where $ C[i] $ are symmetric  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__syrk__batchf_ga9febfef5913e417a169253881b64e423}{blas\+\_\+csyrk\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const bblas\+\_\+complex32\+\_\+t alpha, bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$A, int lda, const bblas\+\_\+complex32\+\_\+t beta, bblas\+\_\+complex32\+\_\+t $\ast$$\ast$C, int ldc, int $\ast$info)
\item 
void \hyperlink{group__syrk__batchf_gaf7aebb3698636b020b8c6b5a09715011}{blas\+\_\+dsyrk\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const double alpha, double const $\ast$const $\ast$A, int lda, const double beta, double $\ast$$\ast$C, int ldc, int $\ast$info)
\item 
void \hyperlink{group__syrk__batchf_ga1406866a70d2f1b721b114c517f503dd}{blas\+\_\+ssyrk\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const float alpha, float const $\ast$const $\ast$A, int lda, const float beta, float $\ast$$\ast$C, int ldc, int $\ast$info)
\item 
void \hyperlink{group__syrk__batchf_gaeec75ae41dc2d56a6de96e5407d83ad2}{blas\+\_\+zsyrk\+\_\+batchf} (int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const bblas\+\_\+complex64\+\_\+t alpha, bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$A, int lda, const bblas\+\_\+complex64\+\_\+t beta, bblas\+\_\+complex64\+\_\+t $\ast$$\ast$C, int ldc, int $\ast$info)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
$ C[i] = \alpha[i] A[i] A[i]^T + \beta[i] C[i] $ where $ C[i] $ are symmetric 



\subsection{Function Documentation}
\index{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}!blas\+\_\+csyrk\+\_\+batchf@{blas\+\_\+csyrk\+\_\+batchf}}
\index{blas\+\_\+csyrk\+\_\+batchf@{blas\+\_\+csyrk\+\_\+batchf}!syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}}
\subsubsection[{\texorpdfstring{blas\+\_\+csyrk\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const bblas\+\_\+complex32\+\_\+t alpha, bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$\+A, int lda, const bblas\+\_\+complex32\+\_\+t beta, bblas\+\_\+complex32\+\_\+t $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_csyrk_batchf(int group_size, bblas_enum_t layout, bblas_enum_t uplo, bblas_enum_t trans, int n, int k, const bblas_complex32_t alpha, bblas_complex32_t const *const *A, int lda, const bblas_complex32_t beta, bblas_complex32_t **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+csyrk\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{uplo, }
\item[{bblas\+\_\+enum\+\_\+t}]{trans, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{const bblas\+\_\+complex32\+\_\+t}]{alpha, }
\item[{bblas\+\_\+complex32\+\_\+t const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const bblas\+\_\+complex32\+\_\+t}]{beta, }
\item[{bblas\+\_\+complex32\+\_\+t $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__syrk__batchf_ga9febfef5913e417a169253881b64e423}{}\label{group__syrk__batchf_ga9febfef5913e417a169253881b64e423}
Performs one of the batch symmetric rank k operations

\[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i], \] or \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i], \]

where alpha and beta are scalars, C\mbox{[}i\mbox{]}-\/s are n-\/by-\/n symmetric matrices, and A\mbox{[}i\mbox{]}-\/s are n-\/by-\/k matrices in the first case and a k-\/by-\/n matrices in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em uplo} & 
\begin{DoxyItemize}
\item Bblas\+Upper\+: Upper triangle of C\mbox{[}i\mbox{]}-\/s are stored;
\item Bblas\+Lower\+: Lower triangle of C\mbox{[}i\mbox{]}-\/s are stored.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em trans} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: \[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i]; \]
\item Bblas\+Trans\+: \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i]. \]
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em n} & The order of the matrices C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & If trans = Bblas\+No\+Trans, number of columns of matrices A\mbox{[}i\mbox{]}; if trans = Bblas\+Trans, number of rows of matrices A\mbox{[}i\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix A\mbox{[}i\mbox{]} of size lda-\/by-\/ka. If trans = Bblas\+No\+Trans, ka = k; if trans = Bblas\+Trans, ka = n.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the arrays A\mbox{[}i\mbox{]}. If trans = Bblas\+No\+Trans, lda $>$= max(1, n); if trans = Bblas\+Trans, lda $>$= max(1, k).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]} .. C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element C\mbox{[}i\mbox{]} is a pointer to a matrix C\mbox{[}i\mbox{]} of size ldc-\/by-\/n. On exit, the uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the arrays C\mbox{[}i\mbox{]}. ldc $>$= max(1, n).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be atleast (group\+\_\+count$\ast$group\+\_\+size).
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be atleast to (group\+\_\+count).
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be atleast 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be atleast 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
csyrk\+\_\+batchf 

csyrk\+\_\+batchf 

dsyrk\+\_\+batchf 

ssyrk\+\_\+batchf 
\end{DoxySeeAlso}
\index{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}!blas\+\_\+dsyrk\+\_\+batchf@{blas\+\_\+dsyrk\+\_\+batchf}}
\index{blas\+\_\+dsyrk\+\_\+batchf@{blas\+\_\+dsyrk\+\_\+batchf}!syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}}
\subsubsection[{\texorpdfstring{blas\+\_\+dsyrk\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const double alpha, double const $\ast$const $\ast$\+A, int lda, const double beta, double $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_dsyrk_batchf(int group_size, bblas_enum_t layout, bblas_enum_t uplo, bblas_enum_t trans, int n, int k, const double alpha, double const *const *A, int lda, const double beta, double **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+dsyrk\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{uplo, }
\item[{bblas\+\_\+enum\+\_\+t}]{trans, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{const double}]{alpha, }
\item[{double const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const double}]{beta, }
\item[{double $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__syrk__batchf_gaf7aebb3698636b020b8c6b5a09715011}{}\label{group__syrk__batchf_gaf7aebb3698636b020b8c6b5a09715011}
Performs one of the batch symmetric rank k operations

\[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i], \] or \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i], \]

where alpha and beta are scalars, C\mbox{[}i\mbox{]}-\/s are n-\/by-\/n symmetric matrices, and A\mbox{[}i\mbox{]}-\/s are n-\/by-\/k matrices in the first case and a k-\/by-\/n matrices in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em uplo} & 
\begin{DoxyItemize}
\item Bblas\+Upper\+: Upper triangle of C\mbox{[}i\mbox{]}-\/s are stored;
\item Bblas\+Lower\+: Lower triangle of C\mbox{[}i\mbox{]}-\/s are stored.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em trans} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: \[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i]; \]
\item Bblas\+Trans\+: \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i]. \]
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em n} & The order of the matrices C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & If trans = Bblas\+No\+Trans, number of columns of matrices A\mbox{[}i\mbox{]}; if trans = Bblas\+Trans, number of rows of matrices A\mbox{[}i\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix A\mbox{[}i\mbox{]} of size lda-\/by-\/ka. If trans = Bblas\+No\+Trans, ka = k; if trans = Bblas\+Trans, ka = n.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the arrays A\mbox{[}i\mbox{]}. If trans = Bblas\+No\+Trans, lda $>$= max(1, n); if trans = Bblas\+Trans, lda $>$= max(1, k).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]} .. C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element C\mbox{[}i\mbox{]} is a pointer to a matrix C\mbox{[}i\mbox{]} of size ldc-\/by-\/n. On exit, the uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the arrays C\mbox{[}i\mbox{]}. ldc $>$= max(1, n).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be atleast (group\+\_\+count$\ast$group\+\_\+size).
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be atleast to (group\+\_\+count).
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be atleast 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be atleast 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
dsyrk\+\_\+batchf 

csyrk\+\_\+batchf 

dsyrk\+\_\+batchf 

ssyrk\+\_\+batchf 
\end{DoxySeeAlso}
\index{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}!blas\+\_\+ssyrk\+\_\+batchf@{blas\+\_\+ssyrk\+\_\+batchf}}
\index{blas\+\_\+ssyrk\+\_\+batchf@{blas\+\_\+ssyrk\+\_\+batchf}!syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}}
\subsubsection[{\texorpdfstring{blas\+\_\+ssyrk\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const float alpha, float const $\ast$const $\ast$\+A, int lda, const float beta, float $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_ssyrk_batchf(int group_size, bblas_enum_t layout, bblas_enum_t uplo, bblas_enum_t trans, int n, int k, const float alpha, float const *const *A, int lda, const float beta, float **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+ssyrk\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{uplo, }
\item[{bblas\+\_\+enum\+\_\+t}]{trans, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{const float}]{alpha, }
\item[{float const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const float}]{beta, }
\item[{float $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__syrk__batchf_ga1406866a70d2f1b721b114c517f503dd}{}\label{group__syrk__batchf_ga1406866a70d2f1b721b114c517f503dd}
Performs one of the batch symmetric rank k operations

\[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i], \] or \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i], \]

where alpha and beta are scalars, C\mbox{[}i\mbox{]}-\/s are n-\/by-\/n symmetric matrices, and A\mbox{[}i\mbox{]}-\/s are n-\/by-\/k matrices in the first case and a k-\/by-\/n matrices in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em uplo} & 
\begin{DoxyItemize}
\item Bblas\+Upper\+: Upper triangle of C\mbox{[}i\mbox{]}-\/s are stored;
\item Bblas\+Lower\+: Lower triangle of C\mbox{[}i\mbox{]}-\/s are stored.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em trans} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: \[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i]; \]
\item Bblas\+Trans\+: \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i]. \]
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em n} & The order of the matrices C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & If trans = Bblas\+No\+Trans, number of columns of matrices A\mbox{[}i\mbox{]}; if trans = Bblas\+Trans, number of rows of matrices A\mbox{[}i\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix A\mbox{[}i\mbox{]} of size lda-\/by-\/ka. If trans = Bblas\+No\+Trans, ka = k; if trans = Bblas\+Trans, ka = n.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the arrays A\mbox{[}i\mbox{]}. If trans = Bblas\+No\+Trans, lda $>$= max(1, n); if trans = Bblas\+Trans, lda $>$= max(1, k).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]} .. C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element C\mbox{[}i\mbox{]} is a pointer to a matrix C\mbox{[}i\mbox{]} of size ldc-\/by-\/n. On exit, the uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the arrays C\mbox{[}i\mbox{]}. ldc $>$= max(1, n).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be atleast (group\+\_\+count$\ast$group\+\_\+size).
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be atleast to (group\+\_\+count).
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be atleast 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be atleast 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
ssyrk\+\_\+batchf 

csyrk\+\_\+batchf 

dsyrk\+\_\+batchf 

ssyrk\+\_\+batchf 
\end{DoxySeeAlso}
\index{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}!blas\+\_\+zsyrk\+\_\+batchf@{blas\+\_\+zsyrk\+\_\+batchf}}
\index{blas\+\_\+zsyrk\+\_\+batchf@{blas\+\_\+zsyrk\+\_\+batchf}!syrk\+\_\+batchf\+: Batch of same size symmetric rank k update@{syrk\+\_\+batchf\+: Batch of same size symmetric rank k update}}
\subsubsection[{\texorpdfstring{blas\+\_\+zsyrk\+\_\+batchf(int group\+\_\+size, bblas\+\_\+enum\+\_\+t layout, bblas\+\_\+enum\+\_\+t uplo, bblas\+\_\+enum\+\_\+t trans, int n, int k, const bblas\+\_\+complex64\+\_\+t alpha, bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$\+A, int lda, const bblas\+\_\+complex64\+\_\+t beta, bblas\+\_\+complex64\+\_\+t $\ast$$\ast$\+C, int ldc, int $\ast$info)}{blas_zsyrk_batchf(int group_size, bblas_enum_t layout, bblas_enum_t uplo, bblas_enum_t trans, int n, int k, const bblas_complex64_t alpha, bblas_complex64_t const *const *A, int lda, const bblas_complex64_t beta, bblas_complex64_t **C, int ldc, int *info)}}]{\setlength{\rightskip}{0pt plus 5cm}void blas\+\_\+zsyrk\+\_\+batchf (
\begin{DoxyParamCaption}
\item[{int}]{group\+\_\+size, }
\item[{bblas\+\_\+enum\+\_\+t}]{layout, }
\item[{bblas\+\_\+enum\+\_\+t}]{uplo, }
\item[{bblas\+\_\+enum\+\_\+t}]{trans, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{const bblas\+\_\+complex64\+\_\+t}]{alpha, }
\item[{bblas\+\_\+complex64\+\_\+t const $\ast$const $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const bblas\+\_\+complex64\+\_\+t}]{beta, }
\item[{bblas\+\_\+complex64\+\_\+t $\ast$$\ast$}]{C, }
\item[{int}]{ldc, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\hypertarget{group__syrk__batchf_gaeec75ae41dc2d56a6de96e5407d83ad2}{}\label{group__syrk__batchf_gaeec75ae41dc2d56a6de96e5407d83ad2}
Performs one of the batch symmetric rank k operations

\[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i], \] or \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i], \]

where alpha and beta are scalars, C\mbox{[}i\mbox{]}-\/s are n-\/by-\/n symmetric matrices, and A\mbox{[}i\mbox{]}-\/s are n-\/by-\/k matrices in the first case and a k-\/by-\/n matrices in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+\_\+size} & The number of matrices to operate on\\
\hline
\mbox{\tt in}  & {\em layout} & Specifies if the matrix is stored in row major or column major format\+:
\begin{DoxyItemize}
\item Bblas\+Row\+Major\+: Row major format
\item Bblas\+Col\+Major\+: Column major format
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em uplo} & 
\begin{DoxyItemize}
\item Bblas\+Upper\+: Upper triangle of C\mbox{[}i\mbox{]}-\/s are stored;
\item Bblas\+Lower\+: Lower triangle of C\mbox{[}i\mbox{]}-\/s are stored.
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em trans} & 
\begin{DoxyItemize}
\item Bblas\+No\+Trans\+: \[ C[i] = \alpha A[i] \times A[i]^T + \beta C[i]; \]
\item Bblas\+Trans\+: \[ C[i] = \alpha A[i]^T \times A[i] + \beta C[i]. \]
\end{DoxyItemize}\\
\hline
\mbox{\tt in}  & {\em n} & The order of the matrices C\mbox{[}i\mbox{]}. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & If trans = Bblas\+No\+Trans, number of columns of matrices A\mbox{[}i\mbox{]}; if trans = Bblas\+Trans, number of rows of matrices A\mbox{[}i\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of pointers to matrices A\mbox{[}0\mbox{]}, A\mbox{[}1\mbox{]} .. A\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element A\mbox{[}i\mbox{]} is a pointer to a matrix A\mbox{[}i\mbox{]} of size lda-\/by-\/ka. If trans = Bblas\+No\+Trans, ka = k; if trans = Bblas\+Trans, ka = n.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the arrays A\mbox{[}i\mbox{]}. If trans = Bblas\+No\+Trans, lda $>$= max(1, n); if trans = Bblas\+Trans, lda $>$= max(1, k).\\
\hline
\mbox{\tt in}  & {\em beta} & The scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is an array of pointers to matrices C\mbox{[}0\mbox{]}, C\mbox{[}1\mbox{]} .. C\mbox{[}group\+\_\+size-\/1\mbox{]}, where each element C\mbox{[}i\mbox{]} is a pointer to a matrix C\mbox{[}i\mbox{]} of size ldc-\/by-\/n. On exit, the uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the arrays C\mbox{[}i\mbox{]}. ldc $>$= max(1, n).\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of int for error handling. On entry info\mbox{[}0\mbox{]} should have one of the following values
\begin{DoxyItemize}
\item Bblas\+Errors\+Report\+All \+: All errors will be specified on output. Length of the array should be atleast (group\+\_\+count$\ast$group\+\_\+size).
\item Bblas\+Errors\+Report\+Group \+: Single error from each group will be reported. Length of the array should be atleast to (group\+\_\+count).
\item Bblas\+Errors\+Report\+Any \+: Occurence of an error will be indicated by a single integer value, and length of the array should be atleast 1.
\item Bblas\+Errors\+Report\+None \+: No error will be reported on output, and length of the array should be atleast 1.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Bblas\+Success} & successful exit\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
zsyrk\+\_\+batchf 

csyrk\+\_\+batchf 

dsyrk\+\_\+batchf 

ssyrk\+\_\+batchf 
\end{DoxySeeAlso}
